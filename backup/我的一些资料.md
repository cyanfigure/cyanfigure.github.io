# 埃筛
```cpp
#include<bits/stdc++.h>
#define DEBUG(var) cout << "[DEBUG] " << #var << " = " << var << endl;
using namespace std;
bool is_it_a_prime[100000001];
int main(){
    int n;
    cin >> n;
    for(int i = 2; i * i <= n; ++i){
        if(!is_it_a_prime[i]){
            for(int j = i * i; j <= n; j += i){
              is_it_a_prime[j] = 1;
            }
        }
    }
    return 0;
}
```
# 欧筛
```cpp
#include<bits/stdc++.h>
#define DEBUG(var) cout << "[DEBUG] " << #var << " = " << var << endl;
using namespace std;
bool is_it_a_prime[100000001];
int prime[60000001];
int main(){
    int n, l = 0;
    cin >> n;
    for(int i = 2; i <= n; ++i){
        if(!is_it_a_prime[i]) prime[++l] = i;
    for(int j = 1; j <= l; j++){
         if(i * prime[j] > n) break;
         is_it_a_prime[i * prime[j]] = 1;
         if(i % prime[j] == 0) break;
    }
    return 0;
}
```
# 快速幂
## 递归
```cpp
long long fast_power(long long a,long long b){
    if(b == 0) return 1;
    half = fast_power(a, b / 2);
    if(b % 2 == 0) return half * half
    else return half * half * a;
}
```
## 迭代
```cpp
long long fast_power(long long a,long long b){
    ans = 1;
    base = a;
    exponent = b;
    while(exponent > 0){
        if(exponent % 2 == 1) ans = ans * a;
        base *= base;
        exponent /= 2;
    return ans;
}
```
## 排序
### 直接排序
```cpp
sort(arr, arr + length)
```
### 归并排序
```cpp
#include<bits/stdc++.h> 
#define DEBUG(var) cout << "[DEBUG] " << #var << " = " << var << endl;
using namespace std;
long long arr[1000007] = {0, 6, 3, 7, 4, 5, 8, 9, 2};
long long brr[1000007];
void mergeSort(long long left, long long right){
	if(left == right) return;
	long long mid = left + (right - left) / 2;
	mergeSort(left, mid);
	mergeSort(mid + 1, right);
	long long i = left, j = mid + 1, tmp = left;
	while(i <= mid && j <= right) brr[tmp++] = (arr[i] < arr[j]) ? arr[i++] : arr[j++];
	if(i <= mid){
		while(i <= mid) brr[tmp++] = arr[i++];
	}else{
		while(j <= right) brr[tmp++] = arr[j++];
	}
	for(int _ = left; _ <= right; ++_){
		arr[_] = brr[_];
	}
}

int main(){
	int len = 8;
	mergeSort(1, len);
	for(int i = 1; i <= len; ++i) cout << arr[i] << " ";
	return 0;
}
```
### 快速排序
```cpp
#include<bits/stdc++.h>
#define DEBUG(var) cout << "[DEBUG] " << #var << " = " << var << endl;
using namespace std;
int arr[1000007] = {8, 2, 4, 9, 6, 3, 5, 2, 7, 0};
void QuickSort(int left, int right){
    if(left >= right) return;
    int base = arr[left + (right - left) / 2];
    int i, j;
    for(i = left, j = right; i <= j;){
        for(; arr[i] < base;) i++;
        for(; arr[j] > base;) j--;
        if(i <= j) swap(arr[i++], arr[j--]);
    }
    if(left < j) QuickSort(left, j);
    if(i < right) QuickSort(i, right);
}
int main(){
    int N;
    cin >> N;
    for(int i = 0; i < N; i++) cin >> arr[i];
    QuickSort(0, N - 1);
    for(int i = 0; i < N; i++) cout << arr[i] << " ";
    return 0;
}
```
## 贪心算法
## 概述
**贪心算法**（greedy algorithm，又称贪婪算法）是指，在对问题求解时，总是做出在**当前看来**是最好的选择。也就是说，不**从整体最优上**加以考虑，算法得到的是在某种意义上的**局部最优解**。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择。

## 二分

```cpp
#include<bits/stdc++.h>
#define DEBUG(var) cout << "[DEBUG] " << #var << " = " << var << endl;
using namespace std;
int arr[50007];
int binsrc(int tgt, int lft, int rgt){
    int frt = lft, lst = rgt;
    while(frt <= lst){
        int mid = frt + (lst - frt) / 2;
        // DEBUG(mid);
        if(arr[mid] == tgt) return mid;
        else if(arr[mid] < tgt) frt = mid + 1;
        else lst = mid - 1;
    }
    return -1;
}
int main(){
    int num, amt;
    cin >> amt;
    for(int i = 0; i < amt; ++i) cin >> arr[i];
    cin >> num;
    cout << (binsrc(num, 0, amt - 1)) << endl;
    return 0;
}
```
## 数据结构们
### deque
```cpp
#include<bits/stdc++.h>
#define DEBUG(var) cout<<"[DEBUG]"<<#var<<"="<<var<<endl;
using namespace std;
//双端队列模拟

//基本数据
int MAX_N = 2e5+5;
int deque1[MAX_N];
int head = MAX_N / 2, tail = MAX_N / 2; //队头、队尾, 使用中间值防止越界
int front = 1, back = 0;

//判空
bool empty(){return head == tail;}

void push(int x, bool dir){ //dir为false时尾插，否则头插
    if(dir){
        deque1[--head] = x;
    }else{
        deque1[++tail] = x;
    }
}
int find(bool dir){ //dir为false时尾查，否则头查
    if(dir){
        return deque1[head];
    }else{
        return deque1[tail];
    }
}
int pop(bool dir){ //dir为false时尾删，否则头删
    if(dir){
        if(empty()) return -1;
        return deque1[head++];
    }else{
        if(empty()) return -1;
        return deque1[--tail];
    }
}
void clear(){
	head = tail;
}
int count(){
	return tail - head;
}

int main()
{
	//10 5 10 3 7 3 -1
    push(3, back);
    push(5, back);
    push(10, front);
    cout << find(front) << " ";
    cout << find(back) << " ";
    cout << pop(front) << " ";
    cout << find(front) << " ";
    push(7, back);
    cout << pop(back) << " ";
    cout << pop(front) << " ";
    cout << pop(front) << " ";
    cout << pop(front) << " ";
    return 0;
}
```